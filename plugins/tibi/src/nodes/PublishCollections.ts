import { CocoonNode, CocoonNodeContext } from '@cocoon/types';
import matter from 'gray-matter';
import _ from 'lodash';
import path from 'path';
import { CollectionData } from './CreateCollection';
import { ItemWithSlug } from './Slugify';

const castFunction = <T = Function>(fn: string | T): T =>
  _.isString(fn) ? (eval(fn) as T) : (fn as T);

export interface Ports {
  collections: CollectionData | CollectionData[];
  collectionsPath: string;
  data: ItemWithSlug[];
  details: string;
  detailsPath: string;
}

export const PublishCollections: CocoonNode<Ports> = {
  category: 'I/O',
  description: `Publishes a list of collections as markdown files with a frontmatter. It will create a document for each collection.

  Only data items that were published in a collection (or were manually determined to be published regardless via the "details" port) are forwarded on the data port.`,

  in: {
    collections: {
      required: true,
      description: `Collections generated by "CreateCollections" nodes.`,
    },
    collectionsPath: {
      defaultValue: 'collections',
      description: `Path to where the collection documents are published.`,
      hide: true,
    },
    data: {
      required: true,
      description: `Data for the items to be published`,
    },
    details: {
      defaultValue: () => false,
      description: `A function that given an item, determines whether to publish the detail page regardless of whether it is in a collection.`,
    },
    detailsPath: {
      defaultValue: 'details',
      description: `Path to where the detail documents are published.`,
      hide: true,
    },
  },

  out: {
    data: {
      description: `Original data of documents that were published, with the addition of documents that were published bu no longer have associated data (orphans). Data items will additionally contain a list of collections they were published to in the "collection" attribute.`,
    },
  },

  async process(context) {
    const { fs } = context;
    const ports = context.ports.read();
    const { data, details } = ports;
    const detailsPath = await fs.createPath(ports.detailsPath, {
      root: context.definitions.root,
    });

    // Create collections
    const collections = await writeCollectionDocuments(ports, context);

    // Create a list of all detail page slugs
    const doPublish = castFunction<(item: any) => any>(details);
    const detailSlugs: string[] = _.uniq([
      // Collect all existing collection items
      ...((await fs.resolveDirectoryContents(detailsPath)) as string[])
        .map(x => path.basename(x))
        .filter(x => x.endsWith('.md'))
        .map(x => path.basename(x, '.md')),
      // Collect currently listed collection items
      ...collections.flatMap(c => c.items).map(x => x.slug),
      // Collect specifically requested items
      ...data.filter(doPublish).map(x => x.slug),
    ]);

    // Map data by slugs
    const dataBySlug = data.reduce((all, item, i) => {
      all[item.slug] = item;
      return all;
    }, {});

    // Remove orphaned detail documents
    const slugsWithoutData = new Set(
      detailSlugs.filter(x => !(x in dataBySlug))
    );
    slugsWithoutData.forEach(slug => {
      context.debug(`removing orphaned detail page: ${slug}`);
      fs.removeFile(path.join(detailsPath, `${slug}.md`));
    });

    // Resolve data for detail page
    const detailDataBySlug = (await Promise.all(
      detailSlugs
        .filter(slug => !slugsWithoutData.has(slug))
        .map(async slug =>
          slug in dataBySlug
            ? dataBySlug[slug]
            : // Read existing item if we can't find new data for it
              (await readDocument(fs, path.join(detailsPath, `${slug}.md`)))
                .data
        )
    ))
      // Add collection info and path
      .map(item => {
        const collectionsWithItem = collections.filter(
          c => c.items.findIndex(x => x.slug === item.slug) >= 0
        );
        return {
          $path: path.resolve(detailsPath, `${item.slug}.md`),
          collections: collectionsWithItem.map(x => ({
            slug: x.meta.slug,
            position: x.items.findIndex(x => x.slug === item.slug),
          })),
          ...item,
        };
      })
      // Map detail data by slug
      .reduce((all, item) => {
        all[item.slug] = item;
        return all;
      }, {});

    // Write published data
    context.ports.write({ data: Object.values(detailDataBySlug) });

    return `Published ${collections.length} collections`;
  },
};

async function readDocument(fs: CocoonNodeContext['fs'], documentPath: string) {
  return matter(await fs.readFile(documentPath));
}

async function writeDocument(
  fs: CocoonNodeContext['fs'],
  documentPath: string,
  data: object
) {
  const options: any = {
    sortKeys: true,
  };
  if (await fs.checkPath(documentPath)) {
    // Existing templates have their front matter updated. That way they
    // can contain manual content as well.
    const parsed = await readDocument(fs, documentPath);
    const mergedData = _.assign(parsed.data, data);
    await fs.writeFile(
      documentPath,
      matter.stringify('\n' + parsed.content.trim(), mergedData, options)
    );
  } else {
    await fs.writeFile(documentPath, matter.stringify('', data, options));
  }
}

async function writeCollectionDocuments(
  ports: Ports,
  context: CocoonNodeContext<Ports>
) {
  const { fs } = context;
  const collections = _.castArray(ports.collections);
  const collectionsPath = await fs.createPath(ports.collectionsPath, {
    root: context.definitions.root,
  });
  const results = await Promise.all(
    collections.map(async collectionData => {
      const id = collectionData.meta.id;
      const collectionPath = path.resolve(collectionsPath, `${id}.md`);
      await writeDocument(context.fs, collectionPath, {
        ...collectionData.meta,
        items: collectionData.items.map(x => x.slug),
      });
      return { id, path: collectionPath };
    })
  );
  context.debug(`wrote ${results.length} collection documents`, results);
  return collections;
}
